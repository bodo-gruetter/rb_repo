---
title: "R Bootcamp Assignment"
output: html_document
---

# 0. Import Packages
```{r, message=FALSE, warning=FALSE}
library(igraph)
library(mgcv)
library(tidyverse)
```

# 1. Prepare Data
MALIK: Dieser Code ist nur dafür da, damit der Rest funktioniert. Kannst du dann so gestalten wie du möchtest.
```{r}
df.cars <- read.csv2(file="autos.csv", sep = ",", header = T, na.strings = c("", " ", "NA"))
df.cars <- na.omit(df.cars)
df.cars <- df.cars %>% filter(yearOfRegistration > 2010, 
                              yearOfRegistration < 2016, 
                              price < 100000)
df.cars$age <- 2016 - df.cars$yearOfRegistration
```

# 2. Graphical Analysis

# 3. Modelling
## 3.1 The starting model
We have now examined a wide variety of variables and their effects on the target variable using a variety of graphs. Now we want to develop a good model from these findings and compare it with models of different degrees of complexity. To achieve this we must first define a starting model that allows us to be further developed.

In the graphical analysis the following categorical variables have shown significant effects on the price of the vehicles: Year of registration, make, oil type, gearbox, vehicle type and unrepaired damage. The unrepaired damage improves the model only minimally, unlike a dummy model. Therefore this factor is not considered in the starting model.

The numeric variables: horsepower, kilometers and age of the vehicles all show significant effects on the vehicle price. While the effects of kilometer and age can be considered linear, PS shows a cubic effect.

This results in the following starting model:

**price ~ yearOfRegistration + brand + fuelType + gearbox + vehicleType +
s(powerPS) + kilometer + age**

In R we build the following model:

```{r message=FALSE}

starting.model.1 <- price ~ as.factor(yearOfRegistration) + brand + fuelType + gearbox + vehicleType +
   s(powerPS) + kilometer + age

gam.starting.model.1 <- gam(starting.model.1, data = df.cars)

summary(gam.starting.model.1)

```

Relatively quickly something catches our eye. This is when we look at the fuelType factor.In this constellation, no level of fuel type has a significant influence on price. Since our goal is to develop a model that is as good as possible so that all variables have a significant influence on price, we decide to remove this factor from the model.

```{r, message=FALSE}

gam.starting.model.2 <- update(gam.starting.model.1, . ~ . - fuelType)

summary(gam.starting.model.2)

```

The result looks much better. If we now look at the R-squared-value, we can see that it gets only slightly worse by omitting fuelType. If we look at vehicleType, we see that only two levels have a highly significant effect on the price. So we check if omitting this variable changes the R-Squared strongly.

```{r, message=FALSE}

gam.starting.model.3 <- update(gam.starting.model.2, . ~ . - vehicleType)

summary(gam.starting.model.3)

```

We see that the R-Squared again deteriorates only very slightly. What we continue to notice, however, is the strong change in the "brand" factor. One example is the Peugeot brand. This no longer has any significant effect. Besides this brand, the significance values of many other brands have also changed. In the next step we will investigate the effect of omitting this factor on the result of the model hypothesis test.

```{r, message=FALSE}

gam.starting.model.4 <- update(gam.starting.model.3, . ~ . - brand)

summary(gam.starting.model.4)

starting.model <- price ~ as.factor(yearOfRegistration) + gearbox +
   s(powerPS) + kilometer + age

```

The result looks very good. All factors show: There is strong evidence that these have an effect on price. The R-Squared is reduced by almost 10%. Since we want to have a model that is as good as possible but also as simple as possible, this is a good compromise for us. The following model results from our model development:

**price ~ yearOfRegistration + gearbox + s(powerPS) + kilometer + age**

## 3.2 A more complex model
Now that we have derived a relatively simple starting model, which considers only a single polynomial effect, we need a more complex model, which we can compare with the simple model. To get an appropriate comparison, we take our starting model and add interactions to it. Thus, this model considers a new level of complexity. The graphical analysis had shown a slight interaction effect between kilometer and gearbox. We would now like to take this into account. The following model results as comparison model:

**price ~ yearOfRegistration + s(powerPS) + gearbox * kilometer + age**

In R we build the following model:

```{r message=FALSE}

complex.model.1 <- price ~ as.factor(yearOfRegistration) +
   s(powerPS) + gearbox * kilometer + age

gam.complex.model.1 <- gam(complex.model.1, data = df.cars)

summary(gam.complex.model.1)

```

Not surprisingly, this model shows a higher R-squared value than the simpler starting model.

## 3.3 A comparison of the models
We use a 10-fold cross validation to compare the two models.

```{r message=FALSE}

for(i in 1:10){
   df.cars.train.id <- sample(seq_len(nrow(df.cars)),size = floor(0.75*nrow(df.cars)))
   df.cars.train <- df.cars[df.cars.train.id,]
   df.cars.test <- df.cars[-df.cars.train.id,]
   
   #predict data with starting model
   gam.starting.model.train <- gam(starting.model, data = df.cars.train)
   predicted.starting.model.test <- predict(gam.starting.model.train,
                                              newdata = df.cars.test)
   r.squared.starting.model <- cor(predicted.starting.model.test, df.cars.test$price)^2
   
   #predict data with complex model
   gam.complex.model.train <- gam(complex.model, data = df.cars.train)
   predicted.complex.model.test <- predict(gam.complex.model.train,
                                           newdata = df.cars.test)
   r.squared.complex.model <- cor(predicted.complex.model.test, df.cars.test$price)^2
}

mean(r.squared.starting.model)
mean(r.squared.complex.model)

```


# 4. The igraph-Package
## 4.1 An introduction into the graph theory
Using the igraph library, graph algorithms can be easily implemented in R, large graphs can be handled and visualized quickly. Before we can do this, some terms in the context of graphs must be defined. The theoretical basis of graphs is graph theory. It is a branch of mathematics.

A *graph* is a network of relationships between different entities from the real world. These entities are represented in the graph as *nodes*. The nodes have *properties* that describe the corresponding object in the real world. They make it an individual. Nodes are related to each other. They are connected by *edges*.

**A simple example**
Graphs are suitable for displaying data from social networks like Facebook and Twitter. An introductory example will go into this in more detail. The following figure shows a very simple graph with three nodes, five edges and a property name - represented as a key-value construct - in each node. The graph shows a small social network between three users. Billy follows Harry and Harry follows Billy. Ruth and Harry also follow each other. Ruth follows Billy, but Billy does not follow Ruth.

![](simple_graph.png)

## 4.2 Graphs in igraph
In igraph graphs are represented with the class "igraph". Graphs can be directed (D) as seen in the previous example, or they can be undirected (U). Furthermore, graphs can be named (N), weighted (W) - that means that the edges have different weights - and bipartite (B). A bipartite graph has relations between elements of two sets. In contrast to the conventional graph, the relations do not exist from node to node, but from element in set A to element in set B.

In igraph, typically two parameters indicating the size of the graph are specified to form a graph. The number of vertices indicates how many nodes the graph contains and the number of edges indicates how many edges the graph conains.

**A simple example**
Now we want to recreate the simple example of the small social network between Billy, Ruth and Harry. For this we use the "igraph" package, which must first be imported. In this example we will build a graph from a data.frame. So first we have to save the data in data.frames before we can form the graph. These are two data.frames. "user" includes the users Billy, Ruth and Harry. "relations" contains the relations between the three users.

```{r, warning=FALSE}

users <- data.frame(name=c("Billy", "Harry", "Ruth"))
relations <- data.frame(from=c("Billy", "Harry", "Harry", "Ruth", "Ruth"), to=c("Harry", "Billy", "Ruth", "Harry", "Billy"))

g <- graph_from_data_frame(relations, directed=TRUE, vertices=users)
print(g)

```

As the output shows, it is a directed, named graph with 3 nodes and 5 edges. The nodes each have an attribute: name. In the last line, the relations representing the same image as in the figure of the last section are given. Now we ask ourselves the question how we can display the graph visually so that it looks similar to the figure just mentioned.

```{r, warning=FALSE}

plot(g)

```

We use a simple function that we have often used to create charts: plot. As we see, the graphic corresponds to our little social network between Billy, Ruth and Harry.

## 4.3 A further example
